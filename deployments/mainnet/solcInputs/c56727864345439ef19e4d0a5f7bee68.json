{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/Lockable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n */\ncontract Lockable {\n    bool private _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\n    // then call `_postEntranceReset()`.\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n\n    // These functions are intended to be used by child contracts to temporarily disable and re-enable the guard.\n    // Intended use:\n    // _startReentrantGuardDisabled();\n    // ...\n    // _endReentrantGuardDisabled();\n    //\n    // IMPORTANT: these should NEVER be used in a method that isn't inside a nonReentrant block. Otherwise, it's\n    // possible to permanently lock your contract.\n    function _startReentrantGuardDisabled() internal {\n        _notEntered = true;\n    }\n\n    function _endReentrantGuardDisabled() internal {\n        _notEntered = false;\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiCaller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// This contract is taken from Uniswap's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\n\n/// @title MultiCaller\n/// @notice Enables calling multiple methods in a single call to the contract\ncontract MultiCaller {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
    },
    "contracts/AtomicWethDepositor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport \"@uma/core/contracts/common/implementation/Lockable.sol\";\n\ninterface Weth {\n    function withdraw(uint256 _wad) external;\n\n    function transferFrom(address _from, address _to, uint256 _wad) external;\n}\n\n/**\n * @notice Contract deployed on Ethereum helps relay bots atomically unwrap and bridge WETH over the canonical chain\n * bridges for chains that only support bridging of ETH not WETH.\n * @dev This contract is ownable so that the owner can update whitelisted bridge addresses and function selectors.\n */\ncontract AtomicWethDepositor is Ownable, MultiCaller, Lockable {\n    // The Bridge used to send ETH to another chain. Only the function selector can be used when\n    // calling the bridge contract.\n    struct Bridge {\n        address bridge;\n        bytes4 funcSelector;\n    }\n\n    Weth public immutable WETH = Weth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Mapping of chain ID to whitelisted bridge addresses and function selectors\n     * that can be called by this contract.\n     */\n    mapping(uint256 => Bridge) public whitelistedBridgeFunctions;\n\n    ///////////////////////////////\n    //          Events           //\n    ///////////////////////////////\n\n    event AtomicWethDepositInitiated(address indexed from, uint256 indexed chainId, uint256 amount);\n\n    ///////////////////////////////\n    //          Errors           //\n    ///////////////////////////////\n\n    error InvalidBridgeFunction();\n\n    ///////////////////////////////\n    //     Internal Functions    //\n    ///////////////////////////////\n\n    /**\n     * @notice Transfers WETH to this contract and withdraws it to ETH.\n     * @param amount The amount of WETH to withdraw.\n     */\n    function _withdrawWeth(uint256 amount) internal {\n        WETH.transferFrom(msg.sender, address(this), amount);\n        WETH.withdraw(amount);\n    }\n\n    ///////////////////////////////\n    //     Admin Functions       //\n    ///////////////////////////////\n\n    /**\n     * @notice Whitelists function selector and bridge contract for chain.\n     * @param chainId The chain ID of the bridge.\n     * @param bridge The address of the bridge contract to call to bridge ETH to the chain.\n     * @param funcSelector The function selector of the bridge contract.\n     */\n    function whitelistBridge(uint256 chainId, address bridge, bytes4 funcSelector) public onlyOwner {\n        whitelistedBridgeFunctions[chainId] = Bridge({ bridge: bridge, funcSelector: funcSelector });\n    }\n\n    ///////////////////////////////\n    //     Public Functions      //\n    ///////////////////////////////\n\n    /**\n     * @notice Initiates a WETH deposit to a whitelisted bridge for a specified chain with user calldata.\n     * @dev Requires that the owner of this contract has whitelisted the bridge contract and function\n     * selector for the chainId that the user wants to send ETH to.\n     * @param value The amount of WETH to deposit.\n     * @param chainId The chain to send ETH to.\n     * @param bridgeCallData The calldata to pass to the bridge contract. The first 4 bytes should be equal\n     * to the whitelisted function selector of the bridge contract.\n     */\n    function bridgeWeth(uint256 chainId, uint256 value, bytes calldata bridgeCallData) public nonReentrant {\n        _withdrawWeth(value);\n        Bridge memory bridge = whitelistedBridgeFunctions[chainId];\n        if (bridge.funcSelector != bytes4(bridgeCallData)) revert InvalidBridgeFunction();\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = bridge.bridge.call{ value: value }(bridgeCallData);\n        require(success, string(result));\n        emit AtomicWethDepositInitiated(msg.sender, chainId, value);\n    }\n\n    fallback() external payable {}\n\n    // Included to remove a compilation warning.\n    // NOTE: this should not affect behavior.\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}